const { expect } = require('chai');
const { ethers } = require('hardhat');

const toWei = (num) => ethers.utils.parseEther(num.toString());
const fromWei = (num) => ethers.utils.formatEther(num);
// const fromWei = (num) => ethers.utils.formatEther(num.toString());

const getBalance = async (walletAddress) => {
    return new Promise(async (resolve, reject) => {
        const provider = new ethers.providers.JsonRpcProvider(
            'http://localhost:8545'
        )
        await provider
            .getBalance(walletAddress)
            .then((balance) => resolve(balance))
            .catch((err) => reject(err))
    })
}

describe('Dapp Mint NFT', () => {
    let Contract, contract, result;

    const name = 'DappMint NFT';
    const symbol = 'DM';
    const maxSupply = 10;
    const baseURI = 'https://ipfs.io/ipfs/QmTWbe9wDns7aqZQNCuWh5PqybGbBF91kngC5Zf8qmCoyg/';
    const maxMintPerTime = 4;
    const stageOneMax = 4;
    const stageTwoMax = 6;
    const airdropMax = 5;
    const numOfMints = 1;
    const stageOneCost = toWei(0.02);
    const stageTwoCost = toWei(0.04);
    const newCost = toWei(0.1);
    const stageOne = 1;
    const stageTwo = 2;

    beforeEach(async () => {
        Contract = await ethers.getContractFactory('DappMint');
        // deployer is the owner of the contract
        // minter, minter 2 and ... are the minters (accounts generated by ethers)
        [deployer, minter, minter2] = await ethers.getSigners();

        contract = await Contract.deploy(
            baseURI,
            maxSupply,
            stageOneMax,
            stageTwoMax,
            airdropMax,
            deployer.address
        );

        await contract.deployed();
    })

    describe('Deployed', () => {
        it('Should confirm ERC721 info', async () => {
            const _name = await contract.name();
            const _symbol = await contract.symbol();
            expect(_name).to.be.equal(name);
            expect(_symbol).to.be.equal(symbol);
        });

        it('Should confirm deployer', async () => {
            const _deployer = await contract.owner();
            expect(_deployer).to.be.equal(deployer.address);
        })

        it('Should confirm BaseURI', async () => {
            const _baseURI = await contract.baseURI();
            expect(_baseURI).to.be.equal(baseURI);
        })

        it('Should confirm stage capacities', async () => {
            const _maxSupply = await contract.maxSupply();
            const _stageOneMax = await contract.stageOneMax();
            const _stageTwoMax = await contract.stageTwoMax();
            const _airdropMax = await contract.airdropMax();
            const _maxMintPerTime = await contract.maxMintPerTime();
            expect(_maxSupply).to.be.equal(maxSupply);
            expect(_stageOneMax).to.be.equal(stageOneMax);
            expect(_stageTwoMax).to.be.equal(stageTwoMax);
            expect(_airdropMax).to.be.equal(airdropMax);
            expect(_maxMintPerTime).to.be.equal(maxMintPerTime);
        })

        it('Should confirm stage minting cost', async () => {
            const _stageOneCost = await contract.stageOneCost();
            const _stageTwoCost = await contract.stageTwoCost();
            expect(_stageOneCost).to.be.equal(stageOneCost);
            expect(_stageTwoCost).to.be.equal(stageTwoCost);
        })
    })

    describe('Stage One Minting', () => {
        // minting all available NFTs in stage one
        beforeEach(async () => {
            await contract.pause(false, stageOne);
            for (let i = 1; i <= stageOneMax; i++) {
                await contract.connect(minter).mintNFT(numOfMints, stageOne, {
                    value: stageOneCost,
                });
            }
        })

        it('Should confirm stage one minting', async () => {
            const _mintedNFTs = await contract.getMintedNFTs();
            expect(_mintedNFTs).to.have.lengthOf(stageOneMax);
        })
    })

    describe('Stage Two Minting', () => {
        // minting all available NFTs in stage one
        beforeEach(async () => {
            await contract.pause(false, stageTwo);
            for (let i = 1; i <= stageTwoMax; i++) {
                // we use connect function here to mint NFTs (minter is the signer that mints the NFTs)
                await contract.connect(minter).mintNFT(numOfMints, stageTwo, {
                    value: stageTwoCost,
                });
            }
        })

        it('Should confirm stage one minting', async () => {
            const _mintedNFTs = await contract.getMintedNFTs();
            expect(_mintedNFTs).to.have.lengthOf(stageTwoMax);
        })
    })

    describe('Users Personal Minted NFT Cost', () => {
        // minting all available NFTs in stage one
        beforeEach(async () => {
            // by default deployer is the owner of the contract and we don't need to connect as deployer again
            // start stage one minting
            await contract.pause(false, stageOne);
        })

        it('Should confirm minting cost', async () => {
            const _totalCost = await contract.connect(minter).totalCost(minter.address);
            expect(_totalCost).to.be.equal(0);

            for (let i = 1; i <= stageOneMax; i++) {
                await contract.connect(minter).mintNFT(numOfMints, stageOne, {
                    value: stageOneCost,
                });
            }

            const _expectedCost = fromWei(stageOneCost) * stageOneMax;
            const _totalCostAfterMinting = await contract.totalCost(minter.address);
            expect(_totalCostAfterMinting).to.be.equal(toWei(_expectedCost));
        })
    })

    describe('Multi-User Minting', () => {
        beforeEach(async () => {
            // by default deployer is the owner of the contract and we don't need to connect as deployer again
            // start stage one minting
            await contract.pause(false, stageOne);
            await contract.connect(minter).mintNFT(numOfMints, stageOne, {
                value: stageOneCost,
            });
        })

        it('Should confirm minter2 can also mint', async () => {
            let nftNrOfMinter1 = await contract.getOwnerNFTs(minter.address);
            let nftNrOfMinter2 = await contract.getOwnerNFTs(minter2.address);
            expect(nftNrOfMinter1).to.have.lengthOf(1);
            expect(nftNrOfMinter2).to.have.lengthOf(0);

            await contract.connect(minter2).mintNFT(numOfMints, stageOne, {
                value: stageOneCost,
            });

            nftNrOfMinter1 = await contract.getOwnerNFTs(minter.address);
            nftNrOfMinter2 = await contract.getOwnerNFTs(minter2.address);
            expect(nftNrOfMinter1).to.have.lengthOf(1);
            expect(nftNrOfMinter2).to.have.lengthOf(1);
        })
    })

    describe('Administration', () => {
        it('Should confirm minting cost change per stage', async () => {
            let _stageOneCost = await contract.stageOneCost();
            let _stageTwoCost = await contract.stageTwoCost();
            expect(_stageOneCost).to.be.equal(stageOneCost);
            expect(_stageTwoCost).to.be.equal(stageTwoCost);

            let stageOneNewCost = (newCost * 3).toString();
            let stageTwoNewCost = (newCost * 6).toString();
            await contract.setCost(stageOneNewCost, stageOne);
            await contract.setCost(stageTwoNewCost, stageTwo);

            _stageOneCost = await contract.stageOneCost();
            _stageTwoCost = await contract.stageTwoCost();
            expect(_stageOneCost).to.be.equal(stageOneNewCost);
            expect(_stageTwoCost).to.be.equal(stageTwoNewCost);
        })

        it('Should confirm minting pause change per stage', async () => {
            let _stageOnePaused = await contract.stageOnePaused();
            let _stageTwoPaused = await contract.stageTwoPaused();
            expect(_stageOnePaused).to.be.equal(true);
            expect(_stageTwoPaused).to.be.equal(true);

            await contract.pause(false, stageOne);
            await contract.pause(false, stageTwo);

            _stageOnePaused = await contract.stageOnePaused();
            _stageTwoPaused = await contract.stageTwoPaused();
            expect(_stageOnePaused).to.be.equal(false);
            expect(_stageTwoPaused).to.be.equal(false);
        })

        it('Should confirm baseURI change', async () => {
            let _baseURI = await contract.baseURI();
            expect(_baseURI).to.be.equal(baseURI);

            let newBaseURI = 'https://ipfs.io/ipfs/assets';
            await contract.setBaseURI(newBaseURI);
            _baseURI = await contract.baseURI();
            expect(_baseURI).to.be.equal(newBaseURI);
        })

        it('Should confirm max mint per time change', async () => {
            let _maxMintPerTime = await contract.maxMintPerTime();
            expect(_maxMintPerTime).to.be.equal(maxMintPerTime);

            let newMaxMintPerTime = 5;
            await contract.setMaxMintPerTime(newMaxMintPerTime);
            _maxMintPerTime = await contract.maxMintPerTime();
            expect(_maxMintPerTime).to.be.equal(newMaxMintPerTime);
        })
    })

    describe('Withdrawal', () => {
        beforeEach(async () => {
            await contract.pause(false, stageOne);
            for (let i = 1; i <= stageOneMax; i++) {
                await contract.connect(minter).mintNFT(numOfMints, stageOne, {
                    value: stageOneCost,
                });
            }
            await contract.pause(false, stageTwo);
            for (let i = 1; i <= stageTwoMax; i++) {
                await contract.connect(minter).mintNFT(numOfMints, stageTwo, {
                    value: stageTwoCost,
                });
            }
        })

        it('Should confirm withdrawal of funds', async () => {
            let _netRevenue = await contract.netRevenue();
            result = await contract.withdrawTo(
                [minter.address, minter2.address],
                [40, 60],
                '1000' // this is in wei
            )

            result = await contract.netRevenue();
            expect(result).to.be.equal((_netRevenue - 1000).toString());

        });
    });

    describe('Airdrop', () => {
        it('Should confirm balance of airdrop participants', async () => {
            // const mintNo1 = 1;
            // const mintNo2 = 2;
            const droppers = [minter.address, minter2.address];
            const numberOfMints = [1, 2];

            let balanceOfMinter1 = await contract.balanceOf(minter.address);
            let balanceOfMinter2 = await contract.balanceOf(minter2.address);
            expect(balanceOfMinter1).to.be.equal(0);
            expect(balanceOfMinter2).to.be.equal(0);

            await contract.airDropTo(droppers, numberOfMints);

            balanceOfMinter1 = await contract.balanceOf(minter.address);
            balanceOfMinter2 = await contract.balanceOf(minter2.address);
            expect(balanceOfMinter1).to.be.equal(numberOfMints[0]);
            expect(balanceOfMinter2).to.be.equal(numberOfMints[1]);

            let airdroppers = await contract.getAirdroppers();
            expect(airdroppers).to.have.lengthOf(2);
            // airdroppers.map((airdropper) => {
            //     if (airdropper[1] == minter.address) {
            //         expect(JSON.parse(airdropper[0])).to.be.equal(1);
            //     }
            //     if (airdropper[1] == minter2.address) {
            //         expect(JSON.parse(airdropper[0])).to.be.equal(2);
            //     }
            // })
        });
    });

    describe('Trapped cash', () => {
        it('Should confirm withdrawal of trapped cash', async () => {
            const amountInWei = toWei(3.8);

            let contractInitialBalance = await getBalance(contract.address);
            expect(contractInitialBalance).to.be.equal(0);

            await contract.connect(minter2).transfer({ value: amountInWei });

            let contractBalanceAfterTransfer = await contract.netRevenue();
            expect(contractBalanceAfterTransfer).to.be.equal(0);

            await contract.withdrawTrappedCash()

            let contractBalanceAfterTrappedCash = await contract.netRevenue();
            expect(contractBalanceAfterTrappedCash).to.be.equal(amountInWei);

        });
    });

    describe('Whitelist', () => {
        it('Should confirm WL registration', async () => {
            let whitelist = await contract.getWhitelist();
            expect(whitelist).to.have.lengthOf(0);

            await contract.connect(minter2).joinWhitelist();

            whitelist = await contract.getWhitelist();
            expect(whitelist).to.have.lengthOf(1);
        })
    })

    describe('Whitelist Failure', () => {
        it('Should not allow double registration', async () => {
            await contract.connect(minter2).joinWhitelist();
            await expect(contract.connect(minter2).joinWhitelist()).to.be.revertedWith('Account already in the list');
        })
    })

    describe('Minting Failure', () => {
        it('Should not allow minting if paused', async () => {
            await expect(contract.connect(minter2).mintNFT(numOfMints, stageOne)).to.be.revertedWith('Stage 1 is paused. Check back later.');
        })

        it('Should not allow minting when insuficient funds', async () => {
            await contract.pause(false, stageOne);
            await expect(contract.connect(minter2).mintNFT(numOfMints, stageOne)).to.be.revertedWith('Insufficient funds for stage 1');
        })

        it('Should not allow minting when number of mint is zero', async () => {
            await contract.pause(false, stageOne);
            await expect(contract.connect(minter2).mintNFT(0, stageOne, { value: stageOneCost })).to.be.revertedWith('Number of minted NFTs must be greater than 0');
        })
    })

    describe("Withdrawal Failures", () => {
        beforeEach(async () => {
            await contract.pause(false, stageOne);
            await contract.pause(false, stageTwo);

            for (let i = 1; i <= stageOneMax; i++) {
                await contract.connect(minter).mintNFT(numOfMints, stageOne, {
                    value: stageOneCost,
                });
            }

            for (let i = 1; i <= stageTwoMax; i++) {
                await contract.connect(minter).mintNFT(numOfMints, stageTwo, {
                    value: stageTwoCost,
                });
            }


        })

        it('Should prevent others from withdrawing', async () => {
            await expect(
                contract.connect(minter2)
                    .withdrawTo([minter.address, minter2.address], [30, 70], 1000)
            ).to.be.revertedWith('Ownable: caller is not the owner');
        })

        it('Should prevent admin from withdrawing amount less than one', async () => {
            await expect(
                contract.connect(deployer)
                    .withdrawTo([minter.address, minter2.address], [30, 70], 0)
            ).to.be.revertedWith('Amount must be greater than zero');
        })

        it('Should prevent admin from withdrawing amount more than available', async () => {
            let _contractBalance = await contract.netRevenue();
            await expect(
                contract.connect(deployer)
                    .withdrawTo([minter.address, minter2.address], [30, 70], (_contractBalance + 1).toString())
            ).to.be.revertedWith('Insuficient funds');
        })
    })

    describe('Airdrop Failures', () => {
        it('Should prevent empty beneficiaries', async () => {
            const droppers = [];
            const numberOfMints = [];

            await expect(
                contract.airDropTo(droppers, numberOfMints)
            ).to.be.revertedWith('Beneficiary must not be zero');
        })

        it('Should prevent unequal array sizez', async () => {
            const droppers = [minter.address, minter2.address];
            const numberOfMints = [1];

            await expect(
                contract.airDropTo(droppers, numberOfMints)
            ).to.be.revertedWith('Array sizes not matching');
        })

        it('Should prevent airdrop max supply', async () => {
            const droppers = [minter.address, minter2.address];
            const numberOfMints = [airdropMax, 1];

            await expect(
                contract.airDropTo(droppers, numberOfMints)
            ).to.be.revertedWith('Insufficient tokens for airdrop');
        })
    })
})